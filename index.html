<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="images/AK.png">
    <title>Backtracking.com</title>
    <link rel="stylesheet" href="style.css">

</head>

<body>

    <div>
        <h1 class="heading1">Backtracking</h1>
    </div>

    <h2 class="heading2"> Recursion Implementation</h2>

    <p><strong>Backtracking</strong> is a form of <i>recursion</i></p>

    <p><b>Backtracking</b> is an algorithmic-technique for solving problems recursively by to build a solution incrementally, one piece at a time, removing those solutions that fail to satisfy the constraints of the problem at any point of time (by time),
        here, is referred to the time elapsed till any level of the search tree). </p>

    <h4>
        <u>
            <a href="https://en.wikipedia.org/wiki/Backtracking">Accoding to the wikipedia Definition</a>
        </u>
    </h4>

    <p>Backtracking can be defined as a general algorithmic-technique that considers searching every possible combination in order to solve a computational problem</p>

    <p> <b>There are genrally three types of problem with Backtracking :- </b> </p>

    <ul>
        <li><b>Decision Problem</b> - In this type of problem, we search for a feasible solutions.</li>
        <li><b>Optimization Problem </b>- In this type of problem, we search for the best solution.</li>
        <li><b>Enumeration Problem </b>- In this type of problem, we find all feasible solutions.</li>
    </ul>


    <h4>How to determine if a problem can be solved using Backtracking or not?</h4>

    <p>Generally, every constraint satisfaction problem which has clear and well-defined constraints on any objective solution, that incrementally builds candidate to the solution and abandons a candidate (“backtracks”) as soon as it determines that the
        candidate cannot possibly be completed to a valid solution, can be solved by Backtracking. However, most of the problems that are discussed, can be solved using other known algorithms like Dynamic Programming or Greedy Algorithms in logarithmic,
        linear, linear-logarithmic time complexity in order of input size, and therefore, outshine the backtracking algorithm in every respect (since backtracking algorithms are generally exponential in both time and space). However, a few problems still
        remain, that only have backtracking algorithms to solve them until now. </p>

    <p>Consider a situation that you have three boxes in front of you and only one of them has a gold coin in it but you do not know which one. So, in order to get the coin, you will have to open all of the boxes one by one. You will first check the first
        box, if it does not contain the coin, you will have to close it and check the second box and so on until you find the coin. This is what backtracking is, that is solving all sub-problems one by one in order to reach the best possible solution.</p>

    <p>Consider the below example to understand the Backtracking approach more formally,</p>

    <p>Given an instance of any computational problem P and data D corresponding to the instance, all the constraints that need to be satisfied in order to solve the problem are represented by C . A backtracking algorithm will then work as follows:</p>

    <ol> The Algorithm begins to build up a solution, starting with an empty solution set S . S = {}
        <li>Add to S the first move that is still left (All possible moves are added to S one by one). This now creates a new sub-tree s in the search tree of the algorithm.
        </li>
        <li>Check if S+s satisfies each of the constraints in C .</li>
        <ul>
            <li>If Yes, then the sub-tree s is “eligible” to add more “children”.</li>
            <li>Else, the entire sub-tree s is useless, so recurs back to step 1 using argument S .</li>
        </ul>
        <li>In the event of “eligibility” of the newly formed sub-tree s , recurs back to step 1, using argument S+s.</li>
        <li>If the check for S+s returns that it is a solution for the entire data D . Output and terminate the program. If not, then return that no solution is possible with the current s and hence discard it.
        </li>

    </ol>

    <div id="pict"> Here the example in the below picture :</div>
    <center><img src="./images/backtraking.png" alt="backtraking images"></center>

    <ol>
        <li>
            <h4>Recusrsive backtraking solution</h4>
        </li>
        <pre> 
        void findSolutions(n, other params) :
            if (found a solution) :
                solutionsFound = solutionsFound + 1;
                displaySolution();
                if (solutionsFound >= solutionTarget) : 
                    System.exit(0);
                return

        for (val = first to last) :
            if (isValid(val, n)) :
                applyValue(val, n);
                findSolutions(n+1, other params);
                removeValue(val, n);
    </pre>

        <li>
            <h4>finding whether a solution exists or not</h4>
        </li>

        <pre>
        boolean findSolutions(n, other params) :
            if (found a solution) :
            displaySolution();
            return true;

            for (val = first to last) :
            if (isValid(val, n)) :
                applyValue(val, n);
                if (findSolutions(n+1, other params))
                    return true;
            removeValue(val, n);
        return false;
        </pre>
    </ol>

    <h4>Backtracking Algorithm:</h4>
    <p>
        The idea is to place queens one by one in different columns, starting from the leftmost column. When we place a queen in a column, we check for clashes with already placed queens. In the current column, if we find a row for which there is no clash, we
        mark this row and column as part of the solution. If we do not find such a row due to clashes then we backtrack and return false.
    </p>

    <ol>
        <li>
            Start in the leftmost column
        </li>
        <li>If all queens are placed <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true</li>
        <li>Try all rows in the current column. Do following for every tried row.
            <ol type="a">
                <li>
                    If the queen can be placed safely in this row then mark this [row, column] as part of the solution and recursively check if placing queen here leads to a solution.
                </li>

                <li>
                    If placing the queen in [row, column] leads to a solution then return true.
                </li>

                <li>
                    If placing queen doesn't lead to a solution then unmark this [row, column] (Backtrack) and go to step (a) to try other rows.
                </li>
            </ol>
        </li>
    </ol>


    <ol start="3">
        <li>
            If all rows have been tried and nothing worked, return false to trigger backtracking.
        </li>
    </ol>

    <hr size="1">

    <table border="1px" align="center" cellpadding="10px" cellspacing="5px">
        <thead bgcolor="#defffde">
            <th></th>
            <th colspan="3">2 by 3 map</th>
            <!-- <th>3 by 3 map</th>
            <th>3 by 4 map</th> -->
        </thead>

        <tbody align="center">
            <tr>
                <td>Method 1:</td>
                <td>60 ms</td>
                <td>940 ms</td>
                <td>65030ms (1 minute)</td>
            </tr>

            <tr>
                <td>Method 2:</td>
                <td>0 ms</td>
                <td>0 ms</td>
                <td>0 ms (1 Minute)</td>
            </tr>
        </tbody>
        <tfoot>
            <td>total</td>
            <td>1 ms</td>
            <td>1 ms</td>
            <td>1md</td>
        </tfoot>

    </table>

    <h4><a href="contact.html" target="blank">Please Share Your contact</a></h4>
</body>


<footer>
    <p class="copy">Copyright &copy; 2002 by David Matuszek</p>
</footer>

</html>